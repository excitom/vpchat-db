/* add/subtract reward points for a user name.
 * input is the userID 
 * and +/- point delta.
 *
 * output: Return value - 0 - success 
 *                        20001 - No such user 
 *                        20002 - Insufficient funds
 */
IF EXISTS
 (SELECT name FROM sysobjects WHERE name = 'updateUserPoints' AND type = 'P') 
 DROP PROC updateUserPoints
GO  
CREATE PROC updateUserPoints (
    @userID	userIdentifier,
    @points	int
)
AS
BEGIN
  DECLARE @lastError int

  BEGIN TRAN
    
    IF NOT EXISTS (SELECT * FROM users WHERE userID = @userID)
    BEGIN
      ROLLBACK TRAN
      RETURN 20001
    END

    IF @points = 0
    BEGIN
      ROLLBACK TRAN
      RETURN 0
    END

    /* credit transaction */

    IF @points > 0
    BEGIN
      IF EXISTS (SELECT * FROM userPoints WHERE userID = @userID)
      BEGIN
        UPDATE userPoints SET points = points + @points
          WHERE userID = @userID
      END
      ELSE BEGIN
        INSERT userPoints (userID, points)
          VALUES(@userID, @points)
      END
    END

    /* debit transaction */

    ELSE BEGIN
      DECLARE @balance integer
      SELECT @balance = NULL
      SELECT @balance = points FROM userPoints WHERE userID = @userID
      IF @balance IS NULL OR @balance < abs(@points)
      BEGIN
        /* nested transaction kludge. we really should rollback, but to
         * avoid having the calling proc throw an error due to unbalanced
         * transaction count, do a commit here instead. we haven't changed
         * anything yet so a commit is just an expensive no-op.
         */
        IF @@trancount > 1
          COMMIT TRAN
        ELSE
          ROLLBACK TRAN
        RETURN 20002
      END
      UPDATE userPoints SET points = points + @points
        WHERE userID = @userID
    END
    
    SELECT @lastError = @@error
    IF @lastError != 0
    BEGIN
      IF @@trancount = 1
        ROLLBACK TRAN
      RETURN @lastError
    END

  COMMIT TRAN

  EXEC addAcctHistory @userID, 80, @points

END
GO
GRANT EXECUTE ON updateUserPoints TO audset
GO
